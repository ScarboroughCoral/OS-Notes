## 虚拟内存

我们将从一下几个方面学习虚拟内存。

- [三个内存相关的问题](#三个内存相关的问题)
  - 没有足够的内存
  - 地址空间碎片化
  - 地址冲突
- [什么是虚拟内存](#什么是虚拟内存)
  - 中间件
  - 如何解决三个内存问题
  - 页表和转换
- [如何实现虚拟内存](#如何实现虚拟内存)
  - 在什么地方存储页表
  - 怎么让转换变得更快
- [虚拟内存和高速缓存Cache](#虚拟内存和高速缓存Cache)


### 三个内存相关的问题

1. 没有足够的内存怎么办

MIPS提供给每个应用程序32位的地址空间，每个应用程序可以访问这32个地址空间中的任意一个字节。最早的MIPS架构是32位，最新的版本已经变成64位。也就是说你可以使用2^32bytes也就是4GB，这只是理论上，实际可能会缩小到2GB可用空间。

如果你的物理内存（内存条）是1GB该怎么办呢？就像下面这个图，可寻址空间大于实际物理内存大小。

![](/pics/vm-problem1.png)

2. 程序如何分配内存（对于碎片内存）

就像下面这张图，首先内存加载程序p1和p2，开始3G空间被占用，剩余1G空间剩余，这时候p1退出，p3想使用内存，虽然还有2G剩余空间，但空间是碎片化的，这也是一个问题。这被称作**Memory fragmentation**`内存碎片化`。

![](/pics/vm-problem2.png)

3. 如何保证进程安全（进程之间地址不相互访问）

就像下面这张图，两个程序同时访问`1024`这个地址的空间，内存中的信息会不会相互覆盖？

![](/pics/vm-problem3.png)

总结一下，如果所有程序都有相同的32位的寻址空间，那么可能导致以下问题：
* 如果实际物理能存大小小于4GB电脑可能会崩溃
* 如果运行多个程序可能会用光所有内存，这不是真正的用光而是碎片化的内存无法真正利用，这种碎片化依赖于我们不同程序的运行次序
* 不同的进程之间的数据可能会相互覆盖破坏，因为有相同的寻址地址

那么如何解决？

问题的关键在于**所有的程序有相同的寻址空间**，那么我们可不可以有属于自己的**虚拟内存**？如果可以的话，我们可以
1. 将程序的内存空间和物理内存之间做一个映射（这使得我们使用物理内存RAM变的更加灵活）
2. 当程序用光的时候，我们甚至可以将程序移动到硬盘

### 什么是虚拟内存

#### 中间件

虚拟内存是一层“中间组件”，虚拟内存的想法来自于一句话：

> Any problem in computer science can be solved by adding indirection.
任何计算机问题都可以通过添加一个中间件来解决。

如果没有虚拟内存这一层中间件，程序寻址空间将和实际物理内存相同。例如寻址空间大小大于实际RAM大小，如果你访问地址2024，得到的结果可能和访问地址24相同（因为地址越界最高位失效）。

*虚拟内存的作用就是将程序地址空间做一层映射映射到实际RAM地址。*

如下图所示：

![](/pics/whatis-vm1.png)

#### 如何解决三个内存问题

1. 没有足够的内存
将一部分程序地址空间映射到硬盘，我们需要他的时候只需要将这一部分加载到内存中即可。内存中的暂时不使用的程序（比如Program0）可以将其放到硬盘中，这个过程叫做`Page Out`，即内存页换出，并更新映射，然后当新程序（P3）来了就可以映射到内存中原来旧程序（P0）部分。

![](/pics/not-enough-memory.png)

2. 碎片内存使用

这就是前面提到过的问题，如何充分利用程序退出后碎片化的内存？
有了前面提及的映射，这个就比较容易解决了，**我们可以将地址空间按照任意方式映射到实际物理内存RAM**

![](/pics/memory-hole.png)


3. 进程安全（进程之间不相互访问）

进程之间的内存如何能够独立、隔离（isolate）出来呢？例如同时访问`1024`的地址，两个程序如何能保证不是访问的实际物理内存中的同一个区域呢？

通过映射方式我们可以想出来，**只需要保证不同的程序映射到不同的地址空间就可以了。**

![](/pics/program-secure.png)

这样一来，因为每个程序都有自己的地址空间，那么他们不可能访问其他程序的数据，这非常的安全和可靠！

这也是有缺点的，当两个程序合作的时候，如何共享内存呢？**只需要将两个程序各自的地址空间拿出一部分映射到相同的RAM内存**。

![](/pics/memory-share.png)

#### 页表和转换
前面一直提到的映射就是页表的部分，页表所做的功能就是转换，`从VA（Virtual Address）虚拟地址转换为PA（Physical Address）物理地址`。

那程序是如何访问内存的呢？
1. 程序执行使用虚拟地址进行加载。
2. 计算机将虚拟地址转换成物理地址
3. （可选）如果转换过程中发现映射表中没有物理内存，那么操作系统就将它从硬盘加载到内存并修改映射表

![](/pics/vm-work1.png)

4. 计算机通过物理地址读取RAM并将数据返还给程序。

![](/pics/vm-work2.png)



### 如何实现虚拟内存

#### 页表如何存储

#### 如何更快地完成虚拟地址到物理地址的转换



### 虚拟内存和高速缓存Cache



### 参考资料

#### 引用作品

1. David Black-Schaffer.(2014).[Virtual Memory](https://www.youtube.com/watch?v=qcBIvnQt0Bw&index=1&list=PLiwt1iVUib9s2Uo5BeYmwkDFUh70fJPxX)

#### 引用文献
1. Aniruddha-Tapas.(2014).[Operating Systems Notes](https://github.com/Aniruddha-Tapas/Operating-Systems-Notes)
#### 参阅书目
