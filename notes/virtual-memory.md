## 虚拟内存

我们将从一下几个方面学习虚拟内存。

- 三个内存相关的问题
  - 没有足够的内存
  - 地址空间碎片化
  - 地址冲突
- 什么是虚拟内存
  - 中间件
  - 如何解决三个内存问题
  - 页表和转换
- 如何实现虚拟内存
  - 在什么地方存储页表
  - 怎么让转换变得更快
- 虚拟内存和高速缓存Cache


### 三个内存相关的问题

- 没有足够的内存怎么办

MIPS提供给每个应用程序32位的地址空间，每个应用程序可以访问这32个地址空间中的任意一个字节。最早的MIPS架构是32位，最新的版本已经变成64位。也就是说你可以使用2^32bytes也就是4GB，这只是理论上，实际可能会缩小到2GB可用空间。

如果你的物理内存（内存条）是1GB该怎么办呢？就像下面这个图，可寻址空间大于实际物理内存大小。

![](/pics/vm-problem1.png)

- 程序如何分配内存（对于碎片内存）

就像下面这张图，首先内存加载程序p1和p2，开始3G空间被占用，剩余1G空间剩余，这时候p1退出，p3想使用内存，虽然还有2G剩余空间，但空间是碎片化的，这也是一个问题。这被称作**Memory fragmentation**`内存碎片化`。

![](/pics/vm-problem2.png)

- 如何保证进程安全（进程之间地址不相互访问）

就像下面这张图，两个程序同时访问`1024`这个地址的空间，内存中的信息会不会相互覆盖？

![](/pics/vm-problem3.png)

总结一下，如果所有程序都有相同的32位的寻址空间，那么可能导致以下问题：
* 如果实际物理能存大小小于4GB电脑可能会崩溃
* 如果运行多个程序可能会用光所有内存，这不是真正的用光而是碎片化的内存无法真正利用，这种碎片化依赖于我们不同程序的运行次序
* 不同的进程之间的数据可能会相互覆盖破坏，因为有相同的寻址地址

那么如何解决？

问题的关键在于**所有的程序有相同的寻址空间**，那么我们可不可以有属于自己的**虚拟内存**？如果可以的话，我们可以
- 将程序的内存空间和物理内存之间做一个映射（这使得我们使用物理内存RAM变的更加灵活）
- 当程序用光的时候，我们甚至可以将程序移动到硬盘

### 什么是虚拟内存

#### 中间件

虚拟内存是一层“中间组件”，虚拟内存的想法来自于一句话：

> Any problem in computer science can be solved by adding indirection.
任何计算机问题都可以通过添加一个中间件来解决。

如果没有虚拟内存这一层中间件，程序寻址空间将和实际物理内存相同。例如寻址空间大小大于实际RAM大小，如果你访问地址2024，得到的结果可能和访问地址24相同（因为地址越界最高位失效）。

*虚拟内存的作用就是将程序地址空间做一层映射映射到实际RAM地址。*

如下图所示：

![](/pics/whatis-vm1.png)

#### 如何解决三个内存问题

- 没有足够的内存
将一部分程序地址空间映射到硬盘，我们需要他的时候只需要将这一部分加载到内存中即可。内存中的暂时不使用的程序（比如Program0）可以将其放到硬盘中，这个过程叫做`Page Out`，即内存页换出，并更新映射，然后当新程序（P3）来了就可以映射到内存中原来旧程序（P0）部分。

![](/pics/not-enough-memory.png)

- 碎片内存使用

这就是前面提到过的问题，如何充分利用程序退出后碎片化的内存？
有了前面提及的映射，这个就比较容易解决了，**我们可以将地址空间按照任意方式映射到实际物理内存RAM**

![](/pics/memory-hole.png)


- 进程安全（进程之间不相互访问）

进程之间的内存如何能够独立、隔离（isolate）出来呢？例如同时访问`1024`的地址，两个程序如何能保证不是访问的实际物理内存中的同一个区域呢？

通过映射方式我们可以想出来，**只需要保证不同的程序映射到不同的地址空间就可以了。**

![](/pics/program-secure.png)

这样一来，因为每个程序都有自己的地址空间，那么他们不可能访问其他程序的数据，这非常的安全和可靠！

这也是有缺点的，当两个程序合作的时候，如何共享内存呢？**只需要将两个程序各自的地址空间拿出一部分映射到相同的RAM内存**。

![](/pics/memory-share.png)

#### 页表和转换
前面一直提到的映射就是页表的部分，页表所做的功能就是转换，`从VA（Virtual Address）虚拟地址转换为PA（Physical Address）物理地址`。每一个虚拟地址存储单位或者物理地址存储单位成为一个`页`。

那程序是如何访问内存的呢？
- 程序执行使用虚拟地址进行加载。
- 计算机将虚拟地址转换成物理地址
- （可选）如果转换过程中发现映射表中没有物理内存，那么操作系统就将它从硬盘加载到内存并修改映射表

![](/pics/vm-work1.png)

- 计算机通过物理地址读取RAM并将数据返还给程序。

![](/pics/vm-work2.png)

##### 页表

页表保存着VA虚拟地址到PA物理地址的映射方式。

下面一步一步说明页表的构建过程，从有问题的页表到一个臻于完美的页表，这可能是现代计算机操作系统所利用的机制。

既然页表保存着虚拟地址到物理地址的映射，那么页表就需要保存每一个虚拟地址到每一个物理地址的映射，我们称每一条记录为页表入口`Page Table Entry (PTE)`。如果是这样的话，那需要多大的页表？**结合下图：**如果是32位地址空间，每个字就需要1个PTE，这里一个字是32位，也就是4个字节，所以每4个大小也就是2位的地址空间就需要1个PTE，所以总共需要2^30个PTE。又因为每个PTE存储的是一个映射，由于虚拟地址是连续的可以只用偏移地址来表示，只需要存32位的物理地址，所以总共需要2^30x32b=4GB个大小。这说明1个4GB大小的RAM我们就需要拿出全部容量来存储页表，而且这没有考虑每个程序都需要一个页表。如果你没有明白这个计算公式，你仅需要知道如果这样构造页表所需容量太大，需要改造！

![](/pics/page-table1.png)

那么如何改造呢？以上情况的映射是1个字对应一个PTE页表入口，我们称这种情况为`细粒度映射`，那我们可不可以使用`粗粒度映射`呢？就像这个图一样：

![](/pics/page-table2.png)

这个图中，我们将每4Kb大小的地址空间做一个PTE，我们称之为`4KB Pages`，因为每个RAM按字节计量，或者你可以看为1K个字大小的页。这样我们就减少了映射也就是PTE的个数。这4KB大小的页映射的内部是连续的，如下图：

![](/pics/page-table3.png)

有了以上改进，我们有了更少的PTE映射个数，但是我们页降低了使用RAM的灵活性，因为我们每次需要移动一个页（4KB）。

现代计算机系统中，比较典型的就是4KB Pages（1024 words per page，每一页1024个字）。

### 如何实现虚拟内存

#### 页表如何存储

#### 如何更快地完成虚拟地址到物理地址的转换



### 虚拟内存和高速缓存Cache



### 参考资料

#### 引用作品

- David Black-Schaffer.(2014).[Virtual Memory](https://www.youtube.com/watch?v=qcBIvnQt0Bw&index=1&list=PLiwt1iVUib9s2Uo5BeYmwkDFUh70fJPxX)

#### 引用文献
- Aniruddha-Tapas.(2014).[Operating Systems Notes](https://github.com/Aniruddha-Tapas/Operating-Systems-Notes)
#### 参阅书目
